/*!
 * Tenuki v0.3.1 (https://github.com/aprescott/tenuki)
 * Copyright Â© 2016-2019 Adam Prescott.
 * Licensed under the MIT license.
 */
!(function (t) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = t();
  else if ("function" == typeof define && define.amd) define([], t);
  else {
    var e;
    "undefined" != typeof window
      ? (e = window)
      : "undefined" != typeof global
      ? (e = global)
      : "undefined" != typeof self && (e = self),
      (e.tenuki = t());
  }
})(function () {
  var t, e, r;
  return (function a(o, s, u) {
    function l(r, t) {
      if (!s[r]) {
        if (!o[r]) {
          var e = typeof require == "function" && require;
          if (!t && e) return e(r, !0);
          if (f) return f(r, !0);
          var n = new Error("Cannot find module '" + r + "'");
          throw ((n.code = "MODULE_NOT_FOUND"), n);
        }
        var i = (s[r] = { exports: {} });
        o[r][0].call(
          i.exports,
          function (t) {
            var e = o[r][1][t];
            return l(e ? e : t);
          },
          i,
          i.exports,
          a,
          o,
          s,
          u
        );
      }
      return s[r].exports;
    }
    var f = typeof require == "function" && require;
    for (var t = 0; t < u.length; t++) l(u[t]);
    return l;
  })(
    {
      1: [
        function (t, e, r) {
          "use strict";
          r.Game = t("./lib/game").default;
          r.Client = t("./lib/client").default;
          r.utils = t("./lib/utils").default;
        },
        { "./lib/client": 3, "./lib/game": 6, "./lib/utils": 14 },
      ],
      2: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var u = (function () {
            function r(t, e) {
              var r = [];
              var n = true;
              var i = false;
              var a = undefined;
              try {
                for (
                  var o = t[Symbol.iterator](), s;
                  !(n = (s = o.next()).done);
                  n = true
                ) {
                  r.push(s.value);
                  if (e && r.length === e) break;
                }
              } catch (t) {
                i = true;
                a = t;
              } finally {
                try {
                  if (!n && o["return"]) o["return"]();
                } finally {
                  if (i) throw a;
                }
              }
              return r;
            }
            return function (t, e) {
              if (Array.isArray(t)) {
                return t;
              } else if (Symbol.iterator in Object(t)) {
                return r(t, e);
              } else {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance"
                );
              }
            };
          })();
          var n = t("./utils");
          var s = o(n);
          var i = t("./intersection");
          var l = o(i);
          var a = t("./zobrist");
          var v = o(a);
          function o(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var p = function t(e) {
            var r = e.moveNumber,
              n = e.playedPoint,
              i = e.color,
              a = e.pass,
              o = e.blackPassStones,
              s = e.whitePassStones,
              u = e.intersections,
              l = e.blackStonesCaptured,
              f = e.whiteStonesCaptured,
              d = e.capturedPositions,
              c = e.koPoint,
              h = e.boardSize;
            this.moveNumber = r;
            this.playedPoint = n;
            this.color = i;
            this.pass = a;
            this.blackPassStones = o;
            this.whitePassStones = s;
            this.intersections = u;
            this.blackStonesCaptured = l;
            this.whiteStonesCaptured = f;
            this.capturedPositions = d;
            this.koPoint = c;
            this.boardSize = h;
            this._positionHash = v.default.hash(h, u);
            Object.freeze(this);
          };
          p.prototype = {
            copyWithAttributes: function t(e) {
              var r = function t(e) {
                var r = e.moveNumber,
                  n = e.playedPoint,
                  i = e.color,
                  a = e.pass,
                  o = e.blackPassStones,
                  s = e.whitePassStones,
                  u = e.intersections,
                  l = e.blackStonesCaptured,
                  f = e.whiteStonesCaptured,
                  d = e.capturedPositions,
                  c = e.koPoint,
                  h = e.boardSize;
                return {
                  moveNumber: r,
                  playedPoint: n,
                  color: i,
                  pass: a,
                  blackPassStones: o,
                  whitePassStones: s,
                  intersections: u,
                  blackStonesCaptured: l,
                  whiteStonesCaptured: f,
                  capturedPositions: d,
                  koPoint: c,
                  boardSize: h,
                };
              };
              var n = r(this);
              var i = r(Object.assign(n, e));
              return new p(i);
            },
            _capturesFrom: function t(e, r, n) {
              var i = this;
              var a = this.neighborsFor(e, r).filter(function (t) {
                return (
                  !t.isEmpty() && t.value !== n && i.libertiesAt(t.y, t.x) === 1
                );
              });
              var o = s.default.flatMap(a, function (t) {
                return i.groupAt(t.y, t.x);
              });
              return s.default.unique(o);
            },
            _updateIntersection: function t(e, r, n) {
              return r.map(function (t) {
                if (t.y === e.y && t.x === e.x) {
                  return new l.default(t.y, t.x, n);
                } else {
                  return t;
                }
              });
            },
            _removeIntersection: function t(e, r) {
              return this._updateIntersection(e, r, "empty");
            },
            _withoutIntersectionsMatching: function t(e) {
              var r = this.intersections.map(function (t) {
                if (e(t)) {
                  return new l.default(t.y, t.x, "empty");
                } else {
                  return t;
                }
              });
              return this._withNewPoints(r);
            },
            _withNewPoints: function t(e) {
              return this.copyWithAttributes({ intersections: e });
            },
            nextColor: function t() {
              if (this.color === "black") {
                return "white";
              } else {
                return "black";
              }
            },
            yCoordinateFor: function t(e) {
              return this.boardSize - e;
            },
            xCoordinateFor: function t(e) {
              var r = [
                "A",
                "B",
                "C",
                "D",
                "E",
                "F",
                "G",
                "H",
                "J",
                "K",
                "L",
                "M",
                "N",
                "O",
                "P",
                "Q",
                "R",
                "S",
                "T",
              ];
              return r[e];
            },
            playPass: function t(e) {
              var r = {
                moveNumber: this.moveNumber + 1,
                playedPoint: null,
                color: e,
                pass: true,
                blackPassStones: this.blackPassStones,
                whitePassStones: this.whitePassStones,
                intersections: this.intersections,
                blackStonesCaptured: this.blackStonesCaptured,
                whiteStonesCaptured: this.whiteStonesCaptured,
                capturedPositions: [],
                koPoint: null,
                boardSize: this.boardSize,
              };
              r[e + "PassStones"] += 1;
              var n = new p(r);
              return n;
            },
            _simpleKoPoint: function t() {
              var e = null;
              if (this.playedPoint) {
                var r = this.playedPoint,
                  n = r.y,
                  i = r.x;
                if (
                  this.capturedPositions.length === 1 &&
                  this.groupAt(n, i).length === 1 &&
                  this.inAtari(n, i)
                ) {
                  e = this.capturedPositions[0];
                }
              }
              return e;
            },
            playAt: function t(e, r, n) {
              var i = this;
              var a = this._capturesFrom(e, r, n);
              var o = this.intersectionAt(e, r);
              var s = this.intersections;
              a.forEach(function (t) {
                s = i._removeIntersection(t, s);
              });
              s = this._updateIntersection(o, s, n);
              var u = this.blackStonesCaptured + (n === "black" ? 0 : a.length);
              var l = this.whiteStonesCaptured + (n === "white" ? 0 : a.length);
              var f = this.boardSize;
              var d = {
                moveNumber: this.moveNumber + 1,
                playedPoint: Object.freeze({ y: e, x: r }),
                color: n,
                pass: false,
                blackPassStones: this.blackPassStones,
                whitePassStones: this.whitePassStones,
                intersections: s,
                blackStonesCaptured: u,
                whiteStonesCaptured: l,
                capturedPositions: a,
                boardSize: f,
              };
              var c = new p(d);
              var h = c._simpleKoPoint();
              if (h) {
                d["koPoint"] = { y: h.y, x: h.x };
              } else {
                d["koPoint"] = null;
              }
              return new p(d);
            },
            intersectionAt: function t(e, r) {
              if (e >= this.boardSize || r >= this.boardSize) {
                throw new Error(
                  "Intersection at (" +
                    e +
                    ", " +
                    r +
                    ") would be outside the board"
                );
              }
              if (e < 0 || r < 0) {
                throw new Error(
                  "Intersection position cannot be negative, but was given (" +
                    e +
                    ", " +
                    r +
                    ")"
                );
              }
              return this.intersections[e * this.boardSize + r];
            },
            groupAt: function t(e, r) {
              var n = this.intersectionAt(e, r);
              var i = this.partitionTraverse(n, function (t) {
                  return t.sameColorAs(n);
                }),
                a = u(i, 2),
                o = a[0],
                s = a[1];
              return o;
            },
            libertiesAt: function t(e, r) {
              var n = this;
              var i = this.intersectionAt(e, r);
              var a = s.default.flatMap(this.groupAt(i.y, i.x), function (t) {
                return n.neighborsFor(t.y, t.x).filter(function (t) {
                  return t.isEmpty();
                });
              });
              return s.default.unique(a).length;
            },
            inAtari: function t(e, r) {
              return this.libertiesAt(e, r) === 1;
            },
            neighborsFor: function t(e, r) {
              var n = [];
              if (r > 0) {
                n.push(this.intersectionAt(e, r - 1));
              }
              if (r < this.boardSize - 1) {
                n.push(this.intersectionAt(e, r + 1));
              }
              if (e > 0) {
                n.push(this.intersectionAt(e - 1, r));
              }
              if (e < this.boardSize - 1) {
                n.push(this.intersectionAt(e + 1, r));
              }
              return n;
            },
            positionSameAs: function t(e) {
              return (
                this._positionHash === e._positionHash &&
                this.intersections.every(function (t) {
                  return t.sameColorAs(e.intersectionAt(t.y, t.x));
                })
              );
            },
            partitionTraverse: function t(e, r) {
              var n = [];
              var i = [];
              var a = [];
              a.push(e);
              while (a.length > 0) {
                var o = a.pop();
                if (n.indexOf(o) > -1) {
                } else {
                  n.push(o);
                  this.neighborsFor(o.y, o.x).forEach(function (t) {
                    if (n.indexOf(t) > -1) {
                    } else {
                      if (r(t)) {
                        a.push(t);
                      } else {
                        i.push(t);
                      }
                    }
                  });
                }
              }
              return [n, s.default.unique(i)];
            },
          };
          p._initialFor = function (r, t) {
            this._cache = this._cache || {};
            this._cache[r] = this._cache[r] || {};
            if (this._cache[r][t]) {
              return this._cache[r][t];
            }
            var e = Array.apply(null, Array(r * r));
            e = e.map(function (t, e) {
              return new l.default(Math.floor(e / r), e % r);
            });
            var n = r > 11 ? 3 : 2;
            var i = {
              topRight: { y: n, x: r - n - 1 },
              bottomLeft: { y: r - n - 1, x: n },
              bottomRight: { y: r - n - 1, x: r - n - 1 },
              topLeft: { y: n, x: n },
              middle: { y: (r + 1) / 2 - 1, x: (r + 1) / 2 - 1 },
              middleLeft: { y: (r + 1) / 2 - 1, x: n },
              middleRight: { y: (r + 1) / 2 - 1, x: r - n - 1 },
              middleTop: { y: n, x: (r + 1) / 2 - 1 },
              middleBottom: { y: r - n - 1, x: (r + 1) / 2 - 1 },
            };
            var a = {
              0: [],
              1: [],
              2: [i.topRight, i.bottomLeft],
              3: [i.topRight, i.bottomLeft, i.bottomRight],
              4: [i.topRight, i.bottomLeft, i.bottomRight, i.topLeft],
              5: [i.topRight, i.bottomLeft, i.bottomRight, i.topLeft, i.middle],
              6: [
                i.topRight,
                i.bottomLeft,
                i.bottomRight,
                i.topLeft,
                i.middleLeft,
                i.middleRight,
              ],
              7: [
                i.topRight,
                i.bottomLeft,
                i.bottomRight,
                i.topLeft,
                i.middleLeft,
                i.middleRight,
                i.middle,
              ],
              8: [
                i.topRight,
                i.bottomLeft,
                i.bottomRight,
                i.topLeft,
                i.middleLeft,
                i.middleRight,
                i.middleTop,
                i.middleBottom,
              ],
              9: [
                i.topRight,
                i.bottomLeft,
                i.bottomRight,
                i.topLeft,
                i.middleLeft,
                i.middleRight,
                i.middleTop,
                i.middleBottom,
                i.middle,
              ],
            };
            a[t].forEach(function (t) {
              e[t.y * r + t.x] = new l.default(t.y, t.x, "black");
            });
            var o = new p({
              color: t > 1 ? "black" : "white",
              moveNumber: 0,
              intersections: Object.freeze(e),
              blackStonesCaptured: 0,
              whiteStonesCaptured: 0,
              whitePassStones: 0,
              blackPassStones: 0,
              boardSize: r,
            });
            this._cache[r][t] = o;
            return o;
          };
          r.default = p;
        },
        { "./intersection": 7, "./utils": 14, "./zobrist": 15 },
      ],
      3: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = t("./game");
          var o = i(n);
          function i(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function s(t) {
            if (Array.isArray(t)) {
              for (var e = 0, r = Array(t.length); e < t.length; e++) {
                r[e] = t[e];
              }
              return r;
            } else {
              return Array.from(t);
            }
          }
          var a = function t() {
            var e =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : {};
            this._boardElement = e["element"];
            this._setup(e);
          };
          a.prototype = {
            _setup: function t(e) {
              var i = this;
              var r = e.player,
                n = e.gameOptions,
                a = e.hooks;
              this._player = r;
              this._hooks = a;
              if (this._player !== "black" && this._player !== "white") {
                throw new Error(
                  "Player must be either black or white, but was given: " +
                    this._player
                );
              }
              n["_hooks"] = {
                handleClick: function t(e, r) {
                  if (i._busy) {
                    return;
                  }
                  i._busy = true;
                  if (i.isOver()) {
                    var n = i._game
                      .currentState()
                      .groupAt(e, r)
                      .map(function (t) {
                        return { y: t.y, x: t.x, color: t.color };
                      });
                    i._hooks.submitMarkDeadAt(e, r, n, function (t) {
                      if (t) {
                        i._game.toggleDeadAt(e, r);
                      }
                      i._busy = false;
                    });
                  } else {
                    if (
                      i._player !== i.currentPlayer() ||
                      i._game.isIllegalAt(e, r)
                    ) {
                      i._busy = false;
                      return;
                    }
                    i._hooks.submitPlay(e, r, function (t) {
                      if (t) {
                        i._game.playAt(e, r);
                      }
                      i._busy = false;
                    });
                  }
                },
                hoverValue: function t(e, r) {
                  if (
                    !i._busy &&
                    i._player === i.currentPlayer() &&
                    !i.isOver() &&
                    !i._game.isIllegalAt(e, r)
                  ) {
                    return i._player;
                  }
                },
                gameIsOver: function t() {
                  return i.isOver();
                },
              };
              if (this._boardElement) {
                this._game = new o.default(
                  Object.assign({ element: this._boardElement }, n)
                );
              } else {
                this._game = new (Function.prototype.bind.apply(
                  o.default,
                  [null].concat(s(n))
                ))();
              }
            },
            isOver: function t() {
              return this._game.isOver();
            },
            currentPlayer: function t() {
              return this._game.currentPlayer();
            },
            receivePlay: function t(e, r) {
              if (this._player === this.currentPlayer()) {
                return;
              }
              this._game.playAt(e, r);
            },
            moveNumber: function t() {
              return this._game.moveNumber();
            },
            receivePass: function t() {
              if (this._player === this.currentPlayer()) {
                return;
              }
              this._game.pass();
            },
            receiveMarkDeadAt: function t(e, r) {
              this._game.toggleDeadAt(e, r);
            },
            deadStones: function t() {
              return this._game.deadStones();
            },
            setDeadStones: function t(e) {
              this._game._deadPoints = e.map(function (t) {
                return { y: t.y, x: t.x };
              });
              this._game.render();
            },
            pass: function t() {
              var e = this;
              if (
                this._busy ||
                this._player !== this.currentPlayer() ||
                this.isOver()
              ) {
                return;
              }
              this._busy = true;
              this._hooks.submitPass(function (t) {
                if (t) {
                  e._game.pass();
                }
                e._busy = false;
              });
            },
          };
          r.default = a;
        },
        { "./game": 6 },
      ],
      4: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = t("./utils");
          var l = a(n);
          var i = t("./renderer");
          var f = a(i);
          function a(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var o = function t(e, r) {
            var n = r.hooks,
              i = r.options;
            f.default.call(this, e, { hooks: n, options: i });
            if (this.smallerStones) {
              l.default.addClass(e, "tenuki-smaller-stones");
            }
            l.default.addClass(e, "tenuki-dom-renderer");
          };
          o.prototype = Object.create(f.default.prototype);
          o.prototype.constructor = o;
          o.prototype._setup = function (t) {
            f.default.prototype._setup.call(this, t);
            this.BOARD_LENGTH += 1;
            this.computeSizing();
          };
          o.prototype.generateBoard = function (t) {
            var r = this;
            var n = l.default.createElement("div");
            l.default.appendElement(
              n,
              l.default.createElement("div", { class: "lines horizontal" })
            );
            l.default.appendElement(
              n,
              l.default.createElement("div", { class: "lines vertical" })
            );
            l.default.appendElement(
              n,
              l.default.createElement("div", { class: "hoshi-points" })
            );
            l.default.appendElement(
              n,
              l.default.createElement("div", { class: "intersections" })
            );
            f.default.hoshiPositionsFor(t.boardSize).forEach(function (t) {
              var e = l.default.createElement("div", { class: "hoshi" });
              e.style.left = t.left * (r.INTERSECTION_GAP_SIZE + 1) + "px";
              e.style.top = t.top * (r.INTERSECTION_GAP_SIZE + 1) + "px";
              l.default.appendElement(n.querySelector(".hoshi-points"), e);
            });
            for (var e = 0; e < t.boardSize; e++) {
              var i = l.default.createElement("div", {
                class: "line horizontal",
              });
              i.setAttribute("data-left-gutter", t.yCoordinateFor(e));
              l.default.appendElement(n.querySelector(".lines.horizontal"), i);
              var a = l.default.createElement("div", {
                class: "line vertical",
              });
              a.setAttribute("data-top-gutter", t.xCoordinateFor(e));
              l.default.appendElement(n.querySelector(".lines.vertical"), a);
              for (var o = 0; o < t.boardSize; o++) {
                var s = l.default.createElement("div", {
                  class: "intersection empty",
                });
                var u = l.default.createElement("div", { class: "stone" });
                l.default.appendElement(s, u);
                s.setAttribute("data-position-x", o);
                s.setAttribute("data-position-y", e);
                s.style.left = o * (this.INTERSECTION_GAP_SIZE + 1) + "px";
                s.style.top = e * (this.INTERSECTION_GAP_SIZE + 1) + "px";
                l.default.appendElement(n.querySelector(".intersections"), s);
                this.grid[e] = this.grid[e] || [];
                this.grid[e][o] = s;
                this.addIntersectionEventListeners(s, e, o);
              }
            }
            l.default.addEventListener(
              n.querySelector(".lines.horizontal"),
              "mousedown",
              function (t) {
                t.preventDefault();
              }
            );
            l.default.addEventListener(
              n.querySelector(".lines.vertical"),
              "mousedown",
              function (t) {
                t.preventDefault();
              }
            );
            n.querySelector(".lines.horizontal").style.width =
              this.INTERSECTION_GAP_SIZE * (t.boardSize - 1) +
              t.boardSize +
              "px";
            n.querySelector(".lines.horizontal").style.height =
              this.INTERSECTION_GAP_SIZE * (t.boardSize - 1) +
              t.boardSize +
              "px";
            n.querySelector(".lines.vertical").style.width =
              this.INTERSECTION_GAP_SIZE * (t.boardSize - 1) +
              t.boardSize +
              "px";
            n.querySelector(".lines.vertical").style.height =
              this.INTERSECTION_GAP_SIZE * (t.boardSize - 1) +
              t.boardSize +
              "px";
            return n;
          };
          o.prototype.setIntersectionClasses = function (t, e, r) {
            if (t.className !== r.join(" ")) {
              t.className = r.join(" ");
            }
          };
          r.default = o;
        },
        { "./renderer": 10, "./utils": 14 },
      ],
      5: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = function t(e, r) {
            this.boardState = e;
            this.intersection = r;
            Object.freeze(this);
          };
          n.prototype = {
            diagonals: function r() {
              var n = this;
              var r = [];
              var t = [];
              var i = [];
              if (this.intersection.x > 0) {
                t.push(this.intersection.x - 1);
              }
              if (this.intersection.x < this.boardState.boardSize - 1) {
                t.push(this.intersection.x + 1);
              }
              if (this.intersection.y > 0) {
                i.push(this.intersection.y - 1);
              }
              if (this.intersection.y < this.boardState.boardSize - 1) {
                i.push(this.intersection.y + 1);
              }
              t.forEach(function (e) {
                i.forEach(function (t) {
                  r.push(n.boardState.intersectionAt(t, e));
                });
              });
              return r;
            },
            isFalse: function t() {
              if (!this.intersection.isEmpty()) {
                return false;
              }
              var e = this.diagonals();
              var r = e.length <= 2;
              var n = this.neighbors();
              var i = n.filter(function (t) {
                return !t.isEmpty();
              });
              if (r && i.length < 1) {
                return false;
              }
              if (!r && i.length < 2) {
                return false;
              }
              var a = e.filter(function (t) {
                return !t.isEmpty() && !t.sameColorAs(i[0]);
              });
              if (r) {
                return a.length >= 1;
              } else {
                return a.length >= 2;
              }
            },
            neighbors: function t() {
              return this.boardState.neighborsFor(
                this.intersection.y,
                this.intersection.x
              );
            },
            filledColor: function t() {
              if (!this.isFalse()) {
                throw new Error(
                  "Attempting to find filled color for a non-false eye"
                );
              }
              return this.neighbors()[0].value;
            },
          };
          r.default = n;
        },
        {},
      ],
      6: [
        function (t, e, r) {
          "use strict";
          var n =
            typeof Symbol === "function" && typeof Symbol.iterator === "symbol"
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t &&
                    typeof Symbol === "function" &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t;
                };
          Object.defineProperty(r, "__esModule", { value: true });
          var h = (function () {
            function r(t, e) {
              var r = [];
              var n = true;
              var i = false;
              var a = undefined;
              try {
                for (
                  var o = t[Symbol.iterator](), s;
                  !(n = (s = o.next()).done);
                  n = true
                ) {
                  r.push(s.value);
                  if (e && r.length === e) break;
                }
              } catch (t) {
                i = true;
                a = t;
              } finally {
                try {
                  if (!n && o["return"]) o["return"]();
                } finally {
                  if (i) throw a;
                }
              }
              return r;
            }
            return function (t, e) {
              if (Array.isArray(t)) {
                return t;
              } else if (Symbol.iterator in Object(t)) {
                return r(t, e);
              } else {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance"
                );
              }
            };
          })();
          var m =
            typeof Symbol === "function" && n(Symbol.iterator) === "symbol"
              ? function (t) {
                  return typeof t === "undefined" ? "undefined" : n(t);
                }
              : function (t) {
                  return t &&
                    typeof Symbol === "function" &&
                    t.constructor === Symbol &&
                    t !== Symbol.prototype
                    ? "symbol"
                    : typeof t === "undefined"
                    ? "undefined"
                    : n(t);
                };
          var i = t("./dom-renderer");
          var y = d(i);
          var a = t("./svg-renderer");
          var b = d(a);
          var o = t("./null-renderer");
          var s = d(o);
          var u = t("./board-state");
          var S = d(u);
          var l = t("./ruleset");
          var E = d(l);
          var f = t("./scorer");
          var g = d(f);
          function d(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var c = [
            "element",
            "boardSize",
            "scoring",
            "handicapStones",
            "koRule",
            "komi",
            "_hooks",
            "fuzzyStonePlacement",
            "renderer",
            "freeHandicapPlacement",
          ];
          var v = function t() {
            var e =
              arguments.length > 0 && arguments[0] !== undefined
                ? arguments[0]
                : {};
            this._validateOptions(e);
            this._defaultBoardSize = 19;
            this.boardSize = null;
            this._moves = [];
            this.callbacks = { postRender: function t() {} };
            this._boardElement = e["element"];
            this._defaultScoring = "territory";
            this._defaultKoRule = "simple";
            this._defaultRenderer = "svg";
            this._deadPoints = [];
            this._setup(e);
          };
          v.prototype = {
            _validateOptions: function t(e) {
              for (var r in e) {
                if (e.hasOwnProperty(r)) {
                  if (c.indexOf(r) < 0) {
                    throw new Error("Unrecognized game option: " + r);
                  }
                  if (typeof e[r] === "undefined" || e[r] === null) {
                    throw new Error(
                      "Game option " +
                        r +
                        " must not be set as null or undefined"
                    );
                  }
                }
              }
            },
            _configureOptions: function t() {
              var e =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                r = e.boardSize,
                n = r === undefined ? this._defaultBoardSize : r,
                i = e.komi,
                a = i === undefined ? 0 : i,
                o = e.handicapStones,
                s = o === undefined ? 0 : o,
                u = e.freeHandicapPlacement,
                l = u === undefined ? false : u,
                f = e.scoring,
                d = f === undefined ? this._defaultScoring : f,
                c = e.koRule,
                h = c === undefined ? this._defaultKoRule : c,
                v = e.renderer,
                p = v === undefined ? this._defaultRenderer : v;
              if (typeof n !== "number") {
                throw new Error(
                  "Board size must be a number, but was: " +
                    (typeof n === "undefined" ? "undefined" : m(n))
                );
              }
              if (typeof s !== "number") {
                throw new Error(
                  "Handicap stones must be a number, but was: " +
                    (typeof n === "undefined" ? "undefined" : m(n))
                );
              }
              if (s > 0 && n !== 9 && n !== 13 && n !== 19) {
                throw new Error(
                  "Handicap stones not supported on sizes other than 9x9, 13x13 and 19x19"
                );
              }
              if (s < 0 || s === 1 || s > 9) {
                throw new Error("Only 2 to 9 handicap stones are supported");
              }
              if (n > 19) {
                throw new Error("cannot generate a board size greater than 19");
              }
              this.boardSize = n;
              this.handicapStones = s;
              this._freeHandicapPlacement = l;
              this._scorer = new g.default({ scoreBy: d, komi: a });
              this._rendererChoice = { dom: y.default, svg: b.default }[p];
              if (!this._rendererChoice) {
                throw new Error("Unknown renderer: " + p);
              }
              this._ruleset = new E.default({ koRule: h });
              if (this._freeHandicapPlacement) {
                this._initialState = S.default._initialFor(n, 0);
              } else {
                this._initialState = S.default._initialFor(n, s);
              }
            },
            _stillPlayingHandicapStones: function t() {
              return (
                this._freeHandicapPlacement &&
                this.handicapStones > 0 &&
                this._moves.length < this.handicapStones
              );
            },
            _setup: function t() {
              var n = this;
              var e =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {};
              this._validateOptions(e);
              this._configureOptions(e);
              if (this._boardElement) {
                var r = {
                  handleClick: function t(e, r) {
                    if (n.isOver()) {
                      n.toggleDeadAt(e, r);
                    } else {
                      n.playAt(e, r);
                    }
                  },
                  hoverValue: function t(e, r) {
                    if (!n.isOver() && !n.isIllegalAt(e, r)) {
                      return n.currentPlayer();
                    }
                  },
                  gameIsOver: function t() {
                    return n.isOver();
                  },
                };
                this.renderer = new this._rendererChoice(this._boardElement, {
                  hooks: e["_hooks"] || r,
                  options: { fuzzyStonePlacement: e["fuzzyStonePlacement"] },
                });
              } else {
                this.renderer = new s.default();
              }
              this.render();
            },
            intersectionAt: function t(e, r) {
              return this.currentState().intersectionAt(e, r);
            },
            intersections: function t() {
              return this.currentState().intersections;
            },
            deadStones: function t() {
              return this._deadPoints;
            },
            coordinatesFor: function t(e, r) {
              return (
                this.currentState().xCoordinateFor(r) +
                this.currentState().yCoordinateFor(e)
              );
            },
            currentPlayer: function t() {
              if (this._stillPlayingHandicapStones()) {
                return "black";
              }
              return this.currentState().nextColor();
            },
            isWhitePlaying: function t() {
              return this.currentPlayer() === "white";
            },
            isBlackPlaying: function t() {
              return this.currentPlayer() === "black";
            },
            score: function t() {
              return this._scorer.score(this);
            },
            currentState: function t() {
              return this._moves[this._moves.length - 1] || this._initialState;
            },
            moveNumber: function t() {
              return this.currentState().moveNumber;
            },
            playAt: function t(e, r) {
              var n =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : {},
                i = n.render,
                a = i === undefined ? true : i;
              if (this.isIllegalAt(e, r)) {
                return false;
              }
              var o = this.currentState().playAt(e, r, this.currentPlayer());
              var s = o,
                u = s.koPoint;
              if (
                u &&
                !this._ruleset._isKoViolation(
                  u.y,
                  u.x,
                  o,
                  this._moves.concat(o)
                )
              ) {
                o = o.copyWithAttributes({ koPoint: null });
              }
              this._moves.push(o);
              if (a) {
                this.render();
              }
              return true;
            },
            pass: function t() {
              var e =
                  arguments.length > 0 && arguments[0] !== undefined
                    ? arguments[0]
                    : {},
                r = e.render,
                n = r === undefined ? true : r;
              if (this.isOver()) {
                return false;
              }
              var i = this.currentState().playPass(this.currentPlayer());
              this._moves.push(i);
              if (n) {
                this.render();
              }
              return true;
            },
            isOver: function t() {
              if (this._moves.length < 2) {
                return false;
              }
              var e = this._moves[this._moves.length - 1];
              var r = this._moves[this._moves.length - 2];
              return e.pass && r.pass;
            },
            markDeadAt: function t(e, r) {
              var n =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : {},
                i = n.render,
                a = i === undefined ? true : i;
              if (this._isDeadAt(e, r)) {
                return true;
              }
              return this._setDeadStatus(e, r, true, { render: a });
            },
            unmarkDeadAt: function t(e, r) {
              var n =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : {},
                i = n.render,
                a = i === undefined ? true : i;
              if (!this._isDeadAt(e, r)) {
                return true;
              }
              return this._setDeadStatus(e, r, false, { render: a });
            },
            toggleDeadAt: function t(e, r) {
              var n =
                  arguments.length > 2 && arguments[2] !== undefined
                    ? arguments[2]
                    : {},
                i = n.render,
                a = i === undefined ? true : i;
              return this._setDeadStatus(e, r, !this._isDeadAt(e, r), {
                render: a,
              });
            },
            _setDeadStatus: function t(e, r, n) {
              var i = this;
              var a =
                  arguments.length > 3 && arguments[3] !== undefined
                    ? arguments[3]
                    : {},
                o = a.render,
                s = o === undefined ? true : o;
              var u = this.intersectionAt(e, r);
              if (u.isEmpty()) {
                return;
              }
              var l = [];
              var f = this.currentState().partitionTraverse(u, function (t) {
                  return t.isEmpty() || t.sameColorAs(u);
                }),
                d = h(f, 1),
                c = d[0];
              c.forEach(function (t) {
                if (!t.isEmpty()) {
                  l.push(t);
                }
              });
              l.forEach(function (e) {
                if (n) {
                  i._deadPoints.push({ y: e.y, x: e.x });
                } else {
                  i._deadPoints = i._deadPoints.filter(function (t) {
                    return !(t.y === e.y && t.x === e.x);
                  });
                }
              });
              if (s) {
                this.render();
              }
              return true;
            },
            _isDeadAt: function t(e, r) {
              return this._deadPoints.some(function (t) {
                return t.y === e && t.x === r;
              });
            },
            isIllegalAt: function t(e, r) {
              return this._ruleset.isIllegal(e, r, this);
            },
            territory: function t() {
              if (!this.isOver()) {
                return { black: [], white: [] };
              }
              return this._scorer.territory(this);
            },
            undo: function t() {
              this._moves.pop();
              this.render();
            },
            render: function t() {
              if (!this.isOver()) {
                this._deadPoints = [];
              }
              this.renderer.render(this.currentState(), {
                territory: this.territory(),
                deadStones: this.deadStones(),
              });
              this.callbacks.postRender(this);
            },
          };
          r.default = v;
        },
        {
          "./board-state": 2,
          "./dom-renderer": 4,
          "./null-renderer": 8,
          "./ruleset": 11,
          "./scorer": 12,
          "./svg-renderer": 13,
        },
      ],
      7: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = function t(e, r, n) {
            this.y = e;
            this.x = r;
            this.value = n || "empty";
            Object.freeze(this);
          };
          n.prototype = {
            isOccupiedWith: function t(e) {
              if (this.isEmpty()) {
                return false;
              }
              return this.value === e;
            },
            isBlack: function t() {
              return this.value === "black";
            },
            isWhite: function t() {
              return this.value === "white";
            },
            isEmpty: function t() {
              return this.value === "empty";
            },
            sameColorAs: function t(e) {
              return this.value === e.value;
            },
          };
          r.default = n;
        },
        {},
      ],
      8: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          r.default = n;
          function n() {
            this.setup = function () {};
            this.render = function () {};
            this.renderTerritory = function () {};
          }
        },
        {},
      ],
      9: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var l = (function () {
            function r(t, e) {
              var r = [];
              var n = true;
              var i = false;
              var a = undefined;
              try {
                for (
                  var o = t[Symbol.iterator](), s;
                  !(n = (s = o.next()).done);
                  n = true
                ) {
                  r.push(s.value);
                  if (e && r.length === e) break;
                }
              } catch (t) {
                i = true;
                a = t;
              } finally {
                try {
                  if (!n && o["return"]) o["return"]();
                } finally {
                  if (i) throw a;
                }
              }
              return r;
            }
            return function (t, e) {
              if (Array.isArray(t)) {
                return t;
              } else if (Symbol.iterator in Object(t)) {
                return r(t, e);
              } else {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance"
                );
              }
            };
          })();
          var n = t("./utils");
          var u = i(n);
          function i(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var f = function t(e, r) {
            this.boardState = e;
            this.intersections = r;
            this._computed = {};
            Object.freeze(this);
          };
          f._startingAt = function (t, e, r) {
            var n = t.intersectionAt(e, r);
            var i = t.partitionTraverse(n, function (t) {
                return t.sameColorAs(n);
              }),
              a = l(i, 2),
              o = a[0],
              s = a[1];
            return [o, s];
          };
          f.allFor = function (a) {
            var o = [];
            var s = [];
            a.intersections.forEach(function (e) {
              if (o.indexOf(e) > -1) {
              } else {
                var t = a.partitionTraverse(e, function (t) {
                    return t.sameColorAs(e);
                  }),
                  r = l(t, 2),
                  n = r[0],
                  i = r[1];
                s.push(new f(a, n));
                o = o.concat(n);
              }
            });
            return s;
          };
          f.merge = function (t, e) {
            var r = [e];
            var n = -1;
            while (r.length !== n) {
              n = r.length;
              r = t.filter(function (t) {
                return (
                  t.isEmpty() &&
                  t.isTerritory() &&
                  t.territoryColor() === e.territoryColor() &&
                  t.expandedBoundaryStones().some(function (e) {
                    return r.some(function (t) {
                      return t.expandedBoundaryStones().indexOf(e) > -1;
                    });
                  })
                );
              });
            }
            return r;
          };
          f.prototype = {
            isEmpty: function t() {
              return this.intersections[0].isEmpty();
            },
            isTerritory: function t() {
              var e = this.intersections[0];
              if (!e.isEmpty()) {
                return false;
              }
              var r = f._startingAt(this.boardState, e.y, e.x),
                n = l(r, 2),
                i = n[0],
                a = n[1];
              var o = u.default.unique(
                a.map(function (t) {
                  return t.value;
                })
              );
              var t = o.length === 1 && o[0] !== "empty";
              return t;
            },
            territoryColor: function t() {
              var e = this.intersections[0];
              var r = f._startingAt(this.boardState, e.y, e.x),
                n = l(r, 2),
                i = n[0],
                a = n[1];
              var o = u.default.unique(
                a.map(function (t) {
                  return t.value;
                })
              );
              var s = o.length === 1 && o[0] !== "empty";
              if (!e.isEmpty() || !s) {
                throw new Error(
                  "Attempted to obtain territory color for something that isn't territory, region containing " +
                    e.y +
                    "," +
                    e.x
                );
              } else {
                return o[0];
              }
            },
            isBlack: function t() {
              return this.territoryColor() === "black";
            },
            isWhite: function t() {
              return this.territoryColor() === "white";
            },
            isNeutral: function t() {
              return (
                !this.intersections[0].isBlack() &&
                !this.intersections[0].isWhite() &&
                !this.isTerritory()
              );
            },
            exterior: function t() {
              var e = this;
              return this.boardState.intersections.filter(function (t) {
                return (
                  e.intersections.indexOf(t) < 0 &&
                  e.boardState.neighborsFor(t.y, t.x).some(function (t) {
                    return e.intersections.indexOf(t) > -1;
                  })
                );
              });
            },
            boundaryStones: function t() {
              var e = this;
              if (this._computed.boundaryStones) {
                return this._computed.boundaryStones;
              }
              if (!this.isEmpty()) {
                throw new Error(
                  "Attempted to obtain boundary stones for non-empty region"
                );
              }
              this._computed.boundaryStones = this.exterior().filter(function (
                t
              ) {
                return !t.sameColorAs(e.intersections[0]);
              });
              return this._computed.boundaryStones;
            },
            expandedBoundaryStones: function t() {
              if (this._computed.expandedBoundaryStones) {
                return this._computed.expandedBoundaryStones;
              }
              var e = this.boundaryStones();
              var r = f.allFor(this.boardState).filter(function (t) {
                return t.intersections.some(function (t) {
                  return e.indexOf(t) > -1;
                });
              });
              this._computed.expandedBoundaryStones = u.default.flatMap(
                r,
                function (t) {
                  return t.intersections;
                }
              );
              return this._computed.expandedBoundaryStones;
            },
            lengthOfTerritoryBoundary: function t() {
              var e = this;
              var r = this.intersections.filter(function (t) {
                return (
                  t.y === 0 ||
                  t.y === e.boardState.boardSize - 1 ||
                  t.x === 0 ||
                  t.x === e.boardState.boardSize - 1
                );
              });
              var n = this.intersections.filter(function (t) {
                return (
                  (t.y % e.boardState.boardSize) - 1 === 0 &&
                  (t.x % e.boardState.boardSize) - 1 === 0
                );
              });
              return this.boundaryStones().length + r.length + n.length;
            },
            containsSquareFour: function t() {
              var u = this;
              return this.intersections.some(function (s) {
                return [
                  [0, 0],
                  [0, 1],
                  [1, 0],
                  [1, 1],
                ].every(function (t) {
                  var e = l(t, 2),
                    r = e[0],
                    n = e[1];
                  var i = s.y + r;
                  var a = s.x + n;
                  var o =
                    i >= 0 &&
                    i < u.boardState.boardSize &&
                    a >= 0 &&
                    a < u.boardState.boardSize;
                  return o && u.boardState.intersectionAt(i, a).sameColorAs(s);
                });
              });
            },
            containsCurvedFour: function t() {
              var u = this;
              return this.intersections.some(function (s) {
                return [
                  [
                    [0, 0],
                    [1, 0],
                    [2, 0],
                    [2, 1],
                  ],
                  [
                    [-1, 2],
                    [0, 0],
                    [0, 1],
                    [0, 2],
                  ],
                  [
                    [0, 0],
                    [0, 1],
                    [1, 1],
                    [2, 1],
                  ],
                  [
                    [-1, 0],
                    [-1, 1],
                    [-1, 2],
                    [0, 0],
                  ],
                  [
                    [-2, 1],
                    [-1, 1],
                    [0, 0],
                    [0, 1],
                  ],
                  [
                    [0, 0],
                    [1, 0],
                    [1, 1],
                    [1, 2],
                  ],
                  [
                    [0, -1],
                    [0, 0],
                    [1, -1],
                    [2, -1],
                  ],
                  [
                    [-1, -2],
                    [-1, -1],
                    [-1, 0],
                    [0, 0],
                  ],
                ].some(function (t) {
                  return t.every(function (t) {
                    var e = l(t, 2),
                      r = e[0],
                      n = e[1];
                    var i = s.y + r;
                    var a = s.x + n;
                    var o =
                      i >= 0 &&
                      i < u.boardState.boardSize &&
                      a >= 0 &&
                      a < u.boardState.boardSize;
                    return (
                      o && u.boardState.intersectionAt(i, a).sameColorAs(s)
                    );
                  });
                });
              });
            },
            numberOfEyes: function t() {
              if (!this.intersections[0].isEmpty()) {
                throw new Error(
                  "Unexpected calculation of number of eyes for a non-empty region containing " +
                    this.intersections[0].y +
                    "," +
                    this.intersections[0].x
                );
              }
              var e = this.lengthOfTerritoryBoundary();
              if (e < 2) {
                throw new Error(
                  "Unexpected boundary length of " +
                    e +
                    " for region including " +
                    this.intersections[0].y +
                    "," +
                    this.intersections[0].x
                );
              }
              if (e >= 10) {
                return 2;
              }
              var r = void 0;
              switch (e) {
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                  r = 1;
                  break;
                case 7:
                  r = 1.5;
                  break;
                case 8:
                  if (this.containsSquareFour()) {
                    r = 1;
                  } else if (this.containsCurvedFour()) {
                    r = 2;
                  } else {
                    r = 1.5;
                  }
                  break;
                case 9:
                  if (this.containsSquareFour()) {
                    r = 1.5;
                  } else {
                    r = 2;
                  }
                  break;
                default:
                  throw new Error("unhandled boundary length " + e);
              }
              return r;
            },
          };
          r.default = f;
        },
        { "./utils": 14 },
      ],
      10: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var p = (function () {
            function r(t, e) {
              var r = [];
              var n = true;
              var i = false;
              var a = undefined;
              try {
                for (
                  var o = t[Symbol.iterator](), s;
                  !(n = (s = o.next()).done);
                  n = true
                ) {
                  r.push(s.value);
                  if (e && r.length === e) break;
                }
              } catch (t) {
                i = true;
                a = t;
              } finally {
                try {
                  if (!n && o["return"]) o["return"]();
                } finally {
                  if (i) throw a;
                }
              }
              return r;
            }
            return function (t, e) {
              if (Array.isArray(t)) {
                return t;
              } else if (Symbol.iterator in Object(t)) {
                return r(t, e);
              } else {
                throw new TypeError(
                  "Invalid attempt to destructure non-iterable instance"
                );
              }
            };
          })();
          var n = t("./utils");
          var m = i(n);
          function i(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var a = function t(e, r) {
            var n = r.hooks,
              i = r.options;
            this.INTERSECTION_GAP_SIZE = 28;
            this.GUTTER_MARGIN = this.INTERSECTION_GAP_SIZE - 3;
            this.BASE_MARGIN = this.INTERSECTION_GAP_SIZE - 10;
            this.hasCoordinates = e.hasAttribute("data-include-coordinates");
            this.MARGIN = this.hasCoordinates
              ? this.BASE_MARGIN + this.GUTTER_MARGIN
              : this.BASE_MARGIN;
            this.boardElement = e;
            this.grid = [];
            this.hooks = n || {};
            this._options = i || {};
            this._initialized = false;
            if (this._options["fuzzyStonePlacement"]) {
              m.default.addClass(e, "tenuki-fuzzy-placement");
              m.default.removeClass(e, "tenuki-board-flat");
              m.default.addClass(e, "tenuki-board-nonflat");
              this.smallerStones = true;
            }
            this.flatStones = m.default.hasClass(e, "tenuki-board-flat");
            if (!this.flatStones) {
              m.default.addClass(e, "tenuki-board-nonflat");
            }
          };
          a.hoshiPositionsFor = function (t) {
            var e = [];
            if (t < 7) {
              if (t > 1 && t % 2 === 1) {
                var r = {};
                r.top = (t - 1) / 2;
                r.left = r.top;
                e.push(r);
              } else {
              }
            } else {
              var n = t > 11 ? 3 : 2;
              for (var i = 0; i < 3; i++) {
                for (var a = 0; a < 3; a++) {
                  if ((t === 7 || t % 2 === 0) && (i === 1 || a === 1)) {
                    continue;
                  }
                  var o = {};
                  if (i === 0) {
                    o.top = n;
                  }
                  if (i === 1) {
                    o.top = (t + 1) / 2 - 1;
                  }
                  if (i === 2) {
                    o.top = t - n - 1;
                  }
                  if (a === 0) {
                    o.left = n;
                  }
                  if (a === 1) {
                    o.left = (t + 1) / 2 - 1;
                  }
                  if (a === 2) {
                    o.left = t - n - 1;
                  }
                  e.push(o);
                }
              }
            }
            return e;
          };
          a.prototype = {
            _setup: function t(e) {
              var r = this;
              var n = this.boardElement;
              r.BOARD_LENGTH =
                2 * this.MARGIN +
                (e.boardSize - 1) * (this.INTERSECTION_GAP_SIZE + 1);
              var i = m.default.createElement("div", {
                class: "tenuki-inner-container",
              });
              r.innerContainer = i;
              m.default.appendElement(n, i);
              var a = m.default.createElement("div", {
                class: "tenuki-zoom-container",
              });
              r.zoomContainer = a;
              m.default.appendElement(i, a);
              r.cancelZoomElement = m.default.createElement("div", {
                class: "cancel-zoom",
              });
              var o = m.default.createElement("div", {
                class: "cancel-zoom-backdrop",
              });
              m.default.addEventListener(
                r.cancelZoomElement,
                "click",
                function (t) {
                  t.preventDefault();
                  r.zoomOut();
                  return false;
                }
              );
              m.default.addEventListener(o, "click", function (t) {
                t.preventDefault();
                r.zoomOut();
                return false;
              });
              m.default.appendElement(i, r.cancelZoomElement);
              m.default.appendElement(i, o);
              var s = function t(e, r) {
                var n = false;
                var i = function t() {
                  if (n) {
                    return;
                  }
                  n = true;
                  window.requestAnimationFrame(function () {
                    window.dispatchEvent(new CustomEvent(r));
                    n = false;
                  });
                };
                window.addEventListener(e, i);
              };
              s("resize", "optimizedResize");
              var u = this.generateBoard(e, {
                hasCoordinates: this.hasCoordinates,
                smallerStones: this.smallerStones,
                flatStones: this.flatStones,
              });
              m.default.appendElement(a, u);
              window.requestAnimationFrame(function () {
                a.style.willChange = "transform";
                r.computeSizing();
              });
              window.addEventListener("optimizedResize", function () {
                r.computeSizing();
              });
              r.touchmoveChangedTouch = null;
              r.touchstartEventHandler = r.handleTouchStart.bind(r);
              r.touchmoveEventHandler = r.handleTouchMove.bind(r);
              r.touchendEventHandler = r.handleTouchEnd.bind(r);
              m.default.addEventListener(
                r.innerContainer,
                "touchstart",
                r.touchstartEventHandler
              );
              m.default.addEventListener(
                r.innerContainer,
                "touchend",
                r.touchendEventHandler
              );
              m.default.addEventListener(
                r.innerContainer,
                "touchmove",
                r.touchmoveEventHandler
              );
            },
            computeSizing: function t() {
              var e = this;
              var r = this.innerContainer;
              var n = this.zoomContainer;
              var i = this.boardElement;
              r.style.height = "";
              r.style.width = "";
              n.style.height = "";
              n.style.width = "";
              r.style.transform = "";
              i.style.width = "";
              i.style.height = "";
              e._touchEventFired = null;
              r.style.width = e.BOARD_LENGTH + "px";
              r.style.height = e.BOARD_LENGTH + "px";
              n.style.width = e.BOARD_LENGTH + "px";
              n.style.height = e.BOARD_LENGTH + "px";
              var a = r.parentNode.clientWidth / r.clientWidth;
              var o = r.parentNode.clientHeight / r.clientHeight;
              var s = Math.min(a, o);
              if (s > 0) {
                if (s < 1) {
                  m.default.addClass(i, "tenuki-scaled");
                } else {
                  m.default.removeClass(i, "tenuki-scaled");
                }
                if (s < 1 || s > 1) {
                  r.style["transform-origin"] = "top left";
                  r.style.transform = "scale3d(" + s + ", " + s + ", 1)";
                }
              }
              i.style.width = r.getBoundingClientRect().width + "px";
              i.style.height = r.getBoundingClientRect().height + "px";
              n.style.willChange = "";
              window.requestAnimationFrame(function () {
                n.style.willChange = "transform";
              });
            },
            addIntersectionEventListeners: function t(n, i, a) {
              var o = this;
              m.default.addEventListener(n, "mouseenter", function () {
                var t = i;
                var e = a;
                var r = o.hooks.hoverValue(t, e);
                if (r) {
                  m.default.addClass(n, "hovered");
                  m.default.addClass(n, r);
                }
              });
              m.default.addEventListener(n, "mouseleave", function () {
                if (m.default.hasClass(this, "hovered")) {
                  m.default.removeClass(n, "hovered");
                  m.default.removeClass(n, "black");
                  m.default.removeClass(n, "white");
                }
                o.resetTouchedPoint();
              });
              m.default.addEventListener(n, "click", function () {
                var t = i;
                var e = a;
                if (
                  !o._touchEventFired ||
                  document.body.clientWidth / window.innerWidth > 1 ||
                  o.hooks.gameIsOver()
                ) {
                  o.hooks.handleClick(t, e);
                  return;
                }
                if (o.touchedPoint) {
                  if (n === o.touchedPoint) {
                    o.hooks.handleClick(t, e);
                  } else {
                    o.showPossibleMoveAt(n, t, e);
                  }
                } else {
                  o.showPossibleMoveAt(n, t, e);
                }
              });
            },
            handleTouchStart: function t(e) {
              var r = this;
              r._touchEventFired = true;
              if (e.touches.length > 1) {
                if (r.zoomedIn) {
                  e.preventDefault();
                }
                return;
              }
              if (!r.zoomedIn) {
                return;
              }
              var n = e.changedTouches[0].clientX;
              var i = e.changedTouches[0].clientY;
              r.dragStartX = n;
              r.dragStartY = i;
              r.zoomContainer.style.transition = "none";
              r.animationFrameRequestID = window.requestAnimationFrame(
                r.processDragDelta.bind(r)
              );
            },
            handleTouchMove: function t(e) {
              var r = this;
              if (e.touches.length > 1) {
                return;
              }
              if (!r.zoomedIn) {
                return true;
              }
              e.preventDefault();
              r.touchmoveChangedTouch = e.changedTouches[0];
              r.moveInProgress = true;
            },
            handleTouchEnd: function t(e) {
              var r = this;
              if (e.touches.length > 1) {
                return;
              }
              if (!r.zoomedIn) {
                return;
              }
              r.zoomContainer.style.transition = "";
              if (!r.moveInProgress) {
                return;
              }
              r.translateY = r.lastTranslateY;
              r.translateX = r.lastTranslateX;
              r.moveInProgress = false;
              r.touchmoveChangedTouch = null;
              window.cancelAnimationFrame(r.animationFrameRequestID);
            },
            processDragDelta: function t() {
              var e = this;
              if (!e.touchmoveChangedTouch) {
                e.animationFrameRequestID = window.requestAnimationFrame(
                  e.processDragDelta.bind(e)
                );
                return;
              }
              var r = e.innerContainer;
              var n = e.touchmoveChangedTouch.clientX;
              var i = e.touchmoveChangedTouch.clientY;
              var a = n - e.dragStartX;
              var o = i - e.dragStartY;
              var s = e.translateY + o / 2.5;
              var u = e.translateX + a / 2.5;
              if (s > 0.5 * r.clientHeight - e.MARGIN) {
                s = 0.5 * r.clientHeight - e.MARGIN;
              }
              if (u > 0.5 * r.clientWidth - e.MARGIN) {
                u = 0.5 * r.clientWidth - e.MARGIN;
              }
              if (s < -0.5 * r.clientHeight + e.MARGIN) {
                s = -0.5 * r.clientHeight + e.MARGIN;
              }
              if (u < -0.5 * r.clientWidth + e.MARGIN) {
                u = -0.5 * r.clientWidth + e.MARGIN;
              }
              e.zoomContainer.style.transform =
                "translate3d(" +
                2.5 * u +
                "px, " +
                2.5 * s +
                "px, 0) scale3d(2.5, 2.5, 1)";
              e.lastTranslateX = u;
              e.lastTranslateY = s;
              e.animationFrameRequestID = window.requestAnimationFrame(
                e.processDragDelta.bind(e)
              );
            },
            showPossibleMoveAt: function t(e, r, n) {
              var i = this;
              var a = this.boardElement;
              var o = this.zoomContainer;
              i.zoomContainerHeight = i.zoomContainerHeight || o.clientHeight;
              i.zoomContainerWidth = i.zoomContainerWidth || o.clientWidth;
              i.touchedPoint = e;
              if (m.default.hasClass(a, "tenuki-scaled")) {
                var s = r * (this.INTERSECTION_GAP_SIZE + 1);
                var u = n * (this.INTERSECTION_GAP_SIZE + 1);
                var l = 0.5 * i.zoomContainerHeight - s - i.MARGIN;
                var f = 0.5 * i.zoomContainerWidth - u - i.MARGIN;
                o.style.transform =
                  "translate3d(" +
                  2.5 * f +
                  "px, " +
                  2.5 * l +
                  "px, 0) scale3d(2.5, 2.5, 1)";
                i.translateY = l;
                i.translateX = f;
                m.default.addClass(i.cancelZoomElement, "visible");
                i.zoomedIn = true;
              }
            },
            resetTouchedPoint: function t() {
              var e = this;
              e.touchedPoint = null;
            },
            zoomOut: function t() {
              var e = this;
              this.resetTouchedPoint();
              e.zoomContainer.style.transform = "";
              e.zoomContainer.style.transition = "";
              e.dragStartX = null;
              e.dragStartY = null;
              e.translateY = null;
              e.translateX = null;
              e.lastTranslateX = null;
              e.lastTranslateY = null;
              m.default.removeClass(e.cancelZoomElement, "visible");
              e.zoomedIn = false;
            },
            render: function t(e) {
              var r = this;
              var n =
                  arguments.length > 1 && arguments[1] !== undefined
                    ? arguments[1]
                    : {},
                i = n.territory,
                a = n.deadStones;
              if (!this._initialized) {
                this._setup(e);
                this._initialized = true;
              }
              this.resetTouchedPoint();
              this.renderStonesPlayed(e.intersections);
              var o = e.playedPoint;
              this.updateMarkerPoints({ playedPoint: o, koPoint: e.koPoint });
              if (this._options["fuzzyStonePlacement"] && o) {
                var s = [
                  "v-shift-up",
                  "v-shift-upup",
                  "v-shift-down",
                  "v-shift-downdown",
                  "v-shift-none",
                ];
                var u = [
                  "h-shift-left",
                  "h-shift-leftleft",
                  "h-shift-right",
                  "h-shift-rightright",
                  "h-shift-none",
                ];
                var l = s.concat(u);
                var f = l.some(function (t) {
                  return m.default.hasClass(r.grid[o.y][o.x], t);
                });
                if (!f) {
                  var d = m.default.cartesianProduct(s, u);
                  var c = p(d[Math.floor(Math.random() * d.length)], 2),
                    h = c[0],
                    v = c[1];
                  [
                    [-1, 0],
                    [0, -1],
                    [0, 1],
                    [1, 0],
                  ].forEach(function (t) {
                    var e = p(t, 2),
                      s = e[0],
                      u = e[1];
                    if (r.grid[o.y + s] && r.grid[o.y + s][o.x + u]) {
                      var l = r.grid[o.y + s][o.x + u];
                      if (!m.default.hasClass(l, "empty")) {
                        [
                          [
                            -1,
                            0,
                            "v-shift-downdown",
                            "v-shift-up",
                            "v-shift-down",
                          ],
                          [
                            -1,
                            0,
                            "v-shift-downdown",
                            "v-shift-upup",
                            "v-shift-none",
                          ],
                          [
                            -1,
                            0,
                            "v-shift-down",
                            "v-shift-upup",
                            "v-shift-none",
                          ],
                          [1, 0, "v-shift-upup", "v-shift-down", "v-shift-up"],
                          [
                            1,
                            0,
                            "v-shift-upup",
                            "v-shift-downdown",
                            "v-shift-none",
                          ],
                          [
                            1,
                            0,
                            "v-shift-up",
                            "v-shift-downdown",
                            "v-shift-none",
                          ],
                          [
                            0,
                            -1,
                            "h-shift-rightright",
                            "h-shift-left",
                            "h-shift-right",
                          ],
                          [
                            0,
                            -1,
                            "h-shift-rightright",
                            "h-shift-leftleft",
                            "h-shift-none",
                          ],
                          [
                            0,
                            -1,
                            "h-shift-right",
                            "h-shift-leftleft",
                            "h-shift-none",
                          ],
                          [
                            0,
                            1,
                            "h-shift-leftleft",
                            "h-shift-right",
                            "h-shift-left",
                          ],
                          [
                            0,
                            1,
                            "h-shift-leftleft",
                            "h-shift-rightright",
                            "h-shift-none",
                          ],
                          [
                            0,
                            1,
                            "h-shift-left",
                            "h-shift-rightright",
                            "h-shift-none",
                          ],
                        ].forEach(function (t) {
                          var e = p(t, 5),
                            r = e[0],
                            n = e[1],
                            i = e[2],
                            a = e[3],
                            o = e[4];
                          if (
                            s === r &&
                            u === n &&
                            m.default.hasClass(l, i) &&
                            (h === a || v === a)
                          ) {
                            m.default.removeClass(l, i);
                            m.default.addClass(l, o);
                          }
                        });
                      }
                    }
                  });
                  m.default.addClass(this.grid[o.y][o.x], h);
                  m.default.addClass(this.grid[o.y][o.x], v);
                }
              }
              if (a.length > 0 || i.black.length > 0 || i.white.length > 0) {
                this.renderTerritory(i, a);
              }
            },
            renderStonesPlayed: function t(e) {
              var r = this;
              e.forEach(function (t) {
                r.renderIntersection(t);
              });
            },
            updateMarkerPoints: function t(e) {
              var r = e.playedPoint,
                n = e.koPoint;
              var i = this;
              if (n) {
                m.default.addClass(i.grid[n.y][n.x], "ko");
              }
              if (r) {
                m.default.addClass(i.grid[r.y][r.x], "played");
              }
            },
            renderIntersection: function t(e) {
              var r = this;
              var n = r.grid[e.y][e.x];
              var i = ["intersection"];
              if (e.isEmpty()) {
                i.push("empty");
              } else {
                i.push("occupied");
                if (e.isBlack()) {
                  i.push("black");
                } else {
                  i.push("white");
                }
                var a = [
                  "v-shift-up",
                  "v-shift-upup",
                  "v-shift-down",
                  "v-shift-downdown",
                  "v-shift-none",
                  "h-shift-left",
                  "h-shift-leftleft",
                  "h-shift-right",
                  "h-shift-rightright",
                  "h-shift-none",
                ];
                a.forEach(function (t) {
                  if (m.default.hasClass(n, t)) {
                    i.push(t);
                  }
                });
              }
              this.setIntersectionClasses(n, e, i);
            },
            renderTerritory: function t(e, r) {
              var n = this;
              m.default.flatten(this.grid).forEach(function (t) {
                m.default.removeClass(t, "territory-black");
                m.default.removeClass(t, "territory-white");
                m.default.removeClass(t, "dead");
              });
              r.forEach(function (t) {
                m.default.addClass(n.grid[t.y][t.x], "dead");
              });
              e.black.forEach(function (t) {
                m.default.addClass(n.grid[t.y][t.x], "territory-black");
              });
              e.white.forEach(function (t) {
                m.default.addClass(n.grid[t.y][t.x], "territory-white");
              });
            },
          };
          r.default = a;
        },
        { "./utils": 14 },
      ],
      11: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = [
            "simple",
            "positional-superko",
            "situational-superko",
            "natural-situational-superko",
          ];
          var i = function t(e) {
            var r = e.koRule;
            this.koRule = r;
            if (n.indexOf(this.koRule) < 0) {
              throw new Error("Unknown ko rule: " + r);
            }
            Object.freeze(this);
          };
          i.prototype = {
            isIllegal: function t(e, r, n) {
              var i = n.currentState();
              var a = i.intersectionAt(e, r);
              var o =
                !a.isEmpty() ||
                this._wouldBeSuicide(e, r, i) ||
                this._isKoViolation(e, r, i, n._moves);
              return o;
            },
            _isKoViolation: function t(e, r, n, i) {
              var a = false;
              if (this.koRule === "simple") {
                var o = n._simpleKoPoint();
                a = Boolean(o) && e === o.y && r === o.x;
              } else {
                var s = n.playAt(e, r, n.nextColor());
                var u = function t(e) {
                  return (
                    i.length > 0 &&
                    i.some(function (t) {
                      return e(t) && t.positionSameAs(s);
                    })
                  );
                };
                if (this.koRule === "positional-superko") {
                  a = u(function () {
                    return true;
                  });
                } else if (this.koRule === "situational-superko") {
                  a = u(function (t) {
                    return t.color === s.color;
                  });
                } else if (this.koRule === "natural-situational-superko") {
                  a = u(function (t) {
                    return !t.pass && t.color === s.color;
                  });
                } else {
                  throw new Error("Unimplemented ko rule " + this.koRule);
                }
              }
              return a;
            },
            _wouldBeSuicide: function t(e, r, n) {
              var i = n.nextColor();
              var a = n.intersectionAt(e, r);
              var o =
                a.isEmpty() &&
                n.neighborsFor(a.y, a.x).filter(function (t) {
                  return t.isEmpty();
                }).length === 0;
              if (!o) {
                return false;
              }
              var s = n.neighborsFor(a.y, a.x).some(function (t) {
                var e = n.inAtari(t.y, t.x);
                var r = t.isOccupiedWith(i);
                return r && !e;
              });
              if (s) {
                return false;
              }
              var u = n.neighborsFor(a.y, a.x).some(function (t) {
                var e = n.inAtari(t.y, t.x);
                var r = !t.isOccupiedWith(i);
                return r && e;
              });
              if (u) {
                return false;
              }
              return true;
            },
          };
          r.default = i;
        },
        {},
      ],
      12: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = t("./utils");
          var l = d(n);
          var i = t("./intersection");
          var s = d(i);
          var a = t("./region");
          var f = d(a);
          var o = t("./eye-point");
          var u = d(o);
          function d(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var c = function t(e) {
            return e.currentState()._withoutIntersectionsMatching(function (t) {
              return e._isDeadAt(t.y, t.x);
            });
          };
          var h = function t(e) {
            var r = f.default.allFor(e);
            var n = r.filter(function (t) {
              return t.isNeutral();
            });
            if (r.length === 0 || n.length === 0) {
              return e;
            }
            var o = {};
            n.forEach(function (t) {
              var i = null;
              var a = null;
              t.intersections.forEach(function (t) {
                i = i || t.x;
                i = i || t.y;
                var e = Math.abs(t.y - a) + Math.abs(t.x - i);
                var r = ["black", "white"][e % 2];
                var n = new s.default(t.y, t.x, r);
                o[t.y] = o[t.y] || [];
                o[t.y][t.x] = n;
              });
            });
            var i = e.intersections.map(function (t) {
              if (o[t.y] && o[t.y][t.x]) {
                return o[t.y][t.x];
              } else {
                return t;
              }
            });
            return e._withNewPoints(i);
          };
          var v = function t(e) {
            var r = f.default.allFor(e).filter(function (t) {
              return t.isTerritory();
            });
            var n = l.default
              .flatMap(r, function (t) {
                return t.intersections;
              })
              .filter(function (t) {
                return new u.default(e, t).isFalse();
              });
            var a = n.filter(function (t) {
              return e.neighborsFor(t.y, t.x).some(function (t) {
                return e.inAtari(t.y, t.x);
              });
            });
            var o = e;
            var i = function t() {
              var e = o.intersections.map(function (t) {
                if (a.indexOf(t) > -1) {
                  return new s.default(
                    t.y,
                    t.x,
                    new u.default(o, t).filledColor()
                  );
                } else {
                  return t;
                }
              });
              o = o._withNewPoints(e);
              var r = h(o);
              var n = f.default.allFor(r).filter(function (t) {
                return t.isTerritory();
              });
              var i = l.default
                .flatMap(n, function (t) {
                  return t.intersections;
                })
                .filter(function (t) {
                  return new u.default(r, t).isFalse();
                });
              a = i.filter(function (t) {
                return o.neighborsFor(t.y, t.x).some(function (t) {
                  return o.inAtari(t.y, t.x);
                });
              });
            };
            while (a.length > 0) {
              i();
            }
            return o;
          };
          var p = Object.freeze({
            score: function t(e) {
              var r = e.deadStones().filter(function (t) {
                return e.intersectionAt(t.y, t.x).isBlack();
              });
              var n = e.deadStones().filter(function (t) {
                return e.intersectionAt(t.y, t.x).isWhite();
              });
              var i = e.territory();
              var a = e.currentState();
              return {
                black: i.black.length + a.whiteStonesCaptured + n.length,
                white: i.white.length + a.blackStonesCaptured + r.length,
              };
            },
            territory: function t(e) {
              var r = c(e);
              var n = h(r);
              var i = v(n);
              var a = f.default.allFor(i).filter(function (t) {
                return t.isTerritory();
              });
              var o = a.filter(function (t) {
                var e = f.default.merge(a, t);
                var r = e.map(function (t) {
                  return Math.ceil(t.numberOfEyes());
                });
                return (
                  r.length > 0 &&
                  r.reduce(function (t, e) {
                    return t + e;
                  }) >= 2
                );
              });
              var s = o.filter(function (t) {
                return t.isBlack();
              });
              var u = o.filter(function (t) {
                return t.isWhite();
              });
              return {
                black: l.default
                  .flatMap(s, function (t) {
                    return t.intersections;
                  })
                  .map(function (t) {
                    return { y: t.y, x: t.x };
                  }),
                white: l.default
                  .flatMap(u, function (t) {
                    return t.intersections;
                  })
                  .map(function (t) {
                    return { y: t.y, x: t.x };
                  }),
              };
            },
          });
          var m = Object.freeze({
            score: function t(e) {
              var r = e.intersections().filter(function (t) {
                return t.isBlack() && !e._isDeadAt(t.y, t.x);
              });
              var n = e.intersections().filter(function (t) {
                return t.isWhite() && !e._isDeadAt(t.y, t.x);
              });
              var i = e.territory();
              return {
                black: i.black.length + r.length,
                white: i.white.length + n.length,
              };
            },
            territory: function t(e) {
              var r = f.default.allFor(c(e));
              var n = r.filter(function (t) {
                return t.isTerritory();
              });
              var i = n.filter(function (t) {
                return t.isBlack();
              });
              var a = n.filter(function (t) {
                return t.isWhite();
              });
              return {
                black: l.default
                  .flatMap(i, function (t) {
                    return t.intersections;
                  })
                  .map(function (t) {
                    return { y: t.y, x: t.x };
                  }),
                white: l.default
                  .flatMap(a, function (t) {
                    return t.intersections;
                  })
                  .map(function (t) {
                    return { y: t.y, x: t.x };
                  }),
              };
            },
          });
          var y = function t() {
            var e =
                arguments.length > 0 && arguments[0] !== undefined
                  ? arguments[0]
                  : {},
              r = e.scoreBy,
              n = e.komi;
            this._strategy = { area: m, territory: p, equivalence: m }[r];
            this._komi = n;
            if (!this._strategy) {
              throw new Error("Unknown scoring type: " + r);
            }
            if (this._komi === null || typeof this._komi === "undefined") {
              throw new Error("Error initializing scorer without a komi value");
            }
            if (typeof this._komi !== "number") {
              throw new Error("Komi value given is not a number: " + n);
            }
            this._usePassStones = r === "equivalence";
            Object.freeze(this);
          };
          y.prototype = {
            score: function t(e) {
              var r = this._strategy.score(e);
              r.white += this._komi;
              if (this._usePassStones) {
                var n = e.currentState().color !== "white";
                return {
                  black:
                    r.black + e.currentState().whitePassStones + (n ? 1 : 0),
                  white: r.white + e.currentState().blackPassStones,
                };
              } else {
                return r;
              }
            },
            territory: function t(e) {
              return this._strategy.territory(e);
            },
            usingPassStones: function t() {
              return this._usePassStones;
            },
          };
          r.default = y;
        },
        { "./eye-point": 5, "./intersection": 7, "./region": 9, "./utils": 14 },
      ],
      13: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var n = t("./utils");
          var P = a(n);
          var i = t("./renderer");
          var x = a(i);
          function a(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var o = function t(e, r) {
            var n = r.hooks,
              i = r.options;
            x.default.call(this, e, { hooks: n, options: i });
            P.default.addClass(e, "tenuki-svg-renderer");
          };
          o.prototype = Object.create(x.default.prototype);
          o.prototype.constructor = o;
          var k = {};
          var s = function t(n, i, e) {
            var r = e.hasCoordinates,
              a = e.smallerStones,
              o = e.flatStones;
            var s = [i.boardSize, r, a, o].toString();
            var u = P.default.createSVGElement("svg");
            var l = P.default.createSVGElement("defs");
            P.default.appendElement(u, l);
            var f = P.default.createSVGElement("radialGradient", {
              attributes: { id: n.blackGradientID, cy: "15%", r: "50%" },
            });
            P.default.appendElement(
              f,
              P.default.createSVGElement("stop", {
                attributes: { offset: "0%", "stop-color": "hsl(0, 0%, 38%)" },
              })
            );
            P.default.appendElement(
              f,
              P.default.createSVGElement("stop", {
                attributes: { offset: "100%", "stop-color": "#39363D" },
              })
            );
            P.default.appendElement(l, f);
            var d = P.default.createSVGElement("radialGradient", {
              attributes: { id: n.whiteGradientID, cy: "15%", r: "50%" },
            });
            P.default.appendElement(
              d,
              P.default.createSVGElement("stop", {
                attributes: { offset: "0%", "stop-color": "#FFFFFF" },
              })
            );
            P.default.appendElement(
              d,
              P.default.createSVGElement("stop", {
                attributes: { offset: "100%", "stop-color": "#fafdfc" },
              })
            );
            P.default.appendElement(l, d);
            var c = P.default.createSVGElement("g", {
              attributes: {
                class: "contents",
                transform: "translate(" + n.MARGIN + ", " + n.MARGIN + ")",
              },
            });
            P.default.appendElement(u, c);
            var h = void 0;
            if (k[s]) {
              h = P.default.clone(k[s]);
            } else {
              h = P.default.createSVGElement("g", {
                attributes: { class: "lines" },
              });
              for (var v = 0; v < i.boardSize - 1; v++) {
                for (var p = 0; p < i.boardSize - 1; p++) {
                  var m = P.default.createSVGElement("rect", {
                    attributes: {
                      y: v * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                      x: p * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                      width: n.INTERSECTION_GAP_SIZE + 1,
                      height: n.INTERSECTION_GAP_SIZE + 1,
                      class: "line-box",
                    },
                  });
                  P.default.appendElement(h, m);
                }
              }
              k[s] = h;
            }
            P.default.appendElement(c, h);
            var y = P.default.createSVGElement("g", {
              attributes: { class: "hoshi" },
            });
            P.default.appendElement(c, y);
            x.default.hoshiPositionsFor(i.boardSize).forEach(function (t) {
              var e = P.default.createSVGElement("circle", {
                attributes: {
                  class: "hoshi",
                  cy: t.top * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                  cx: t.left * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                  r: 2,
                },
              });
              P.default.appendElement(y, e);
            });
            if (r) {
              (function () {
                var r = P.default.createSVGElement("g", {
                  attributes: {
                    class: "coordinates",
                    transform: "translate(" + n.MARGIN + ", " + n.MARGIN + ")",
                  },
                });
                var t = function t(e) {
                  [
                    16 / 2 +
                      1 -
                      (16 + 16 / 2 + 16 / (2 * 2) + 16 / (2 * 2 * 2)),
                    16 / 2 +
                      1 +
                      (16 + 16 / 2) +
                      (i.boardSize - 1) * (n.INTERSECTION_GAP_SIZE + 1),
                  ].forEach(function (t) {
                    P.default.appendElement(
                      r,
                      P.default.createSVGElement("text", {
                        text: i.xCoordinateFor(e),
                        attributes: {
                          "text-anchor": "middle",
                          y: t - 0.5,
                          x: e * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                        },
                      })
                    );
                  });
                  [
                    -1 * (16 + 16 / 2 + 16 / (2 * 2)),
                    16 +
                      16 / 2 +
                      16 / (2 * 2) +
                      (i.boardSize - 1) * (n.INTERSECTION_GAP_SIZE + 1),
                  ].forEach(function (t) {
                    P.default.appendElement(
                      r,
                      P.default.createSVGElement("text", {
                        text: i.yCoordinateFor(e),
                        attributes: {
                          "text-anchor": "middle",
                          y:
                            e * (n.INTERSECTION_GAP_SIZE + 1) -
                            0.5 +
                            16 / (2 * 2),
                          x: t - 0.5,
                        },
                      })
                    );
                  });
                  P.default.appendElement(u, r);
                };
                for (var e = 0; e < i.boardSize; e++) {
                  t(e);
                }
              })();
            }
            var b = P.default.createSVGElement("g", {
              attributes: { class: "intersections" },
            });
            for (var S = 0; S < i.boardSize; S++) {
              for (var E = 0; E < i.boardSize; E++) {
                var g = P.default.createSVGElement("g", {
                  attributes: { class: "intersection" },
                });
                g.setAttribute("data-intersection-y", S);
                g.setAttribute("data-intersection-x", E);
                P.default.appendElement(b, g);
                var _ = P.default.createSVGElement("g", {
                  attributes: { class: "intersection-inner-container" },
                });
                P.default.appendElement(g, _);
                var w = P.default.createSVGElement("rect", {
                  attributes: {
                    y:
                      S * (n.INTERSECTION_GAP_SIZE + 1) -
                      n.INTERSECTION_GAP_SIZE / 2 -
                      0.5,
                    x:
                      E * (n.INTERSECTION_GAP_SIZE + 1) -
                      n.INTERSECTION_GAP_SIZE / 2 -
                      0.5,
                    width: n.INTERSECTION_GAP_SIZE,
                    height: n.INTERSECTION_GAP_SIZE,
                  },
                });
                P.default.appendElement(_, w);
                var A = n.INTERSECTION_GAP_SIZE / 2;
                if (a) {
                  A -= 1;
                }
                var I = {
                  class: "stone",
                  cy: S * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                  cx: E * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                  r: A,
                };
                if (!o) {
                  P.default.appendElement(
                    _,
                    P.default.createSVGElement("circle", {
                      attributes: {
                        class: "stone-shadow",
                        cy: I["cy"] + 2,
                        cx: I["cx"],
                        r: A,
                      },
                    })
                  );
                }
                var C = P.default.createSVGElement("circle", { attributes: I });
                P.default.appendElement(_, C);
                P.default.appendElement(
                  _,
                  P.default.createSVGElement("circle", {
                    attributes: {
                      class: "marker",
                      cy: S * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                      cx: E * (n.INTERSECTION_GAP_SIZE + 1) - 0.5,
                      r: 4.5,
                    },
                  })
                );
                P.default.appendElement(
                  _,
                  P.default.createSVGElement("rect", {
                    attributes: {
                      class: "ko-marker",
                      y: S * (n.INTERSECTION_GAP_SIZE + 1) - 6 - 0.5,
                      x: E * (n.INTERSECTION_GAP_SIZE + 1) - 6 - 0.5,
                      width: 12,
                      height: 12,
                    },
                  })
                );
                P.default.appendElement(
                  _,
                  P.default.createSVGElement("rect", {
                    attributes: {
                      class: "territory-marker",
                      y: S * (n.INTERSECTION_GAP_SIZE + 1) - 6,
                      x: E * (n.INTERSECTION_GAP_SIZE + 1) - 6,
                      width: 11,
                      height: 11,
                    },
                  })
                );
                n.grid[S] = n.grid[S] || [];
                n.grid[S][E] = g;
                n.addIntersectionEventListeners(g, S, E);
              }
            }
            P.default.appendElement(c, b);
            return u;
          };
          o.prototype.generateBoard = function (t, e) {
            var r = e.hasCoordinates,
              n = e.smallerStones,
              i = e.flatStones;
            this.blackGradientID = P.default.randomID("black-gradient");
            this.whiteGradientID = P.default.randomID("white-gradient");
            var a = s(this, t, {
              hasCoordinates: r,
              smallerStones: n,
              flatStones: i,
            });
            this.svgElement = a;
            this.svgElement.setAttribute("height", this.BOARD_LENGTH);
            this.svgElement.setAttribute("width", this.BOARD_LENGTH);
            return a;
          };
          o.prototype.computeSizing = function () {
            var t = this;
            x.default.prototype.computeSizing.call(this);
            this.svgElement.style.transform = "none";
            window.requestAnimationFrame(function () {
              t.svgElement.style.transform = "";
            });
          };
          o.prototype.setIntersectionClasses = function (t, e, r) {
            if (t.getAttribute("class") !== r.join(" ")) {
              t.setAttribute("class", r.join(" "));
            }
            if (!this.flatStones) {
              if (e.isEmpty()) {
                t.querySelector(".stone").setAttribute("style", "");
              } else {
                var n = window.location.href.split("#")[0];
                t.querySelector(".stone").setAttribute(
                  "style",
                  "fill: url(" + n + "#" + this[e.value + "GradientID"] + ")"
                );
              }
            }
          };
          r.default = o;
        },
        { "./renderer": 10, "./utils": 14 },
      ],
      14: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          r.default = {
            flatten: function t(e) {
              return e.reduce(function (t, e) {
                return t.concat(e);
              });
            },
            flatMap: function t(e, r) {
              return Array.prototype.concat.apply([], e.map(r));
            },
            cartesianProduct: function t(e, r) {
              return this.flatten(
                e.map(function (e) {
                  return r.map(function (t) {
                    return [e, t];
                  });
                })
              );
            },
            randomID: function t(e) {
              var r = [0, 1, 2, 3]
                .map(function () {
                  return Math.floor(Math.random() * 65536)
                    .toString(16)
                    .substring(1);
                })
                .join("");
              return e + "-" + r;
            },
            clone: function t(e) {
              return e.cloneNode(true);
            },
            createElement: function t(e, r) {
              var n = document.createElement(e);
              if (typeof r !== "undefined") {
                if (r.class) {
                  n.className = r.class;
                }
              }
              return n;
            },
            createSVGElement: function t(e, r) {
              var n = this;
              var i = "http://www.w3.org/2000/svg";
              var a = document.createElementNS(i, e);
              if (typeof r !== "undefined") {
                if (r.class) {
                  r.class.split(" ").forEach(function (t) {
                    n.addClass(a, t);
                  });
                }
                if (r.attributes) {
                  Object.keys(r.attributes).forEach(function (t) {
                    a.setAttribute(t, r.attributes[t]);
                  });
                }
                if (r.text) {
                  a.textContent = r.text.toString();
                }
              }
              return a;
            },
            appendElement: function t(e, r) {
              e.insertBefore(r, null);
            },
            addEventListener: function t(e, r, n) {
              e.addEventListener(r, n, false);
            },
            removeClass: function t(e, r) {
              if (!this.hasClass(e, r)) {
                return;
              }
              if (e.classList && e.classList.remove) {
                e.classList.remove(r);
                return;
              }
              var n = RegExp("\\b" + r + "\\b", "g");
              if (e instanceof SVGElement) {
                e.setAttribute("class", e.getAttribute("class").replace(n, ""));
              } else {
                e.className = e.getAttribute("class").replace(n, "");
              }
            },
            addClass: function t(e, r) {
              if (e.classList && e.classList.add) {
                e.classList.add(r);
                return;
              }
              if (e instanceof SVGElement) {
                e.setAttribute("class", e.getAttribute("class") + " " + r);
              } else {
                e.className = e.getAttribute("class") + " " + r;
              }
            },
            hasClass: function t(e, r) {
              if (e.classList && e.classList.contains) {
                return e.classList.contains(r);
              }
              var n = RegExp("\\b" + r + "\\b", "g");
              if (e instanceof SVGElement) {
                return n.test(e.getAttribute("class"));
              } else {
                return n.test(e.className);
              }
            },
            toggleClass: function t(e, r) {
              if (e.classList && e.classList.toggle) {
                e.classList.toggle(r);
                return;
              }
              if (this.hasClass(e, r)) {
                this.removeClass(e, r);
              } else {
                this.addClass(e, r);
              }
            },
            unique: function e(t) {
              var e = [];
              t.forEach(function (t) {
                if (e.indexOf(t) < 0) {
                  e.push(t);
                }
              });
              return e;
            },
          };
        },
        {},
      ],
      15: [
        function (t, e, r) {
          "use strict";
          Object.defineProperty(r, "__esModule", { value: true });
          var a = {};
          function i(t, e, r, n) {
            a[t] = a[t] || {};
            a[t][e] = a[t][e] || {};
            a[t][e][r] = a[t][e][r] || {};
            if (a[t][e][r][n]) {
              return a[t][e][r][n];
            }
            var i = Math.floor(Math.random() * (Math.pow(2, 31) - 1));
            a[t][e][r][n] = i;
            return i;
          }
          r.default = {
            hash: function t(r, e) {
              var n = 0;
              e.forEach(function (t) {
                if (!t.isEmpty()) {
                  var e = i(r, t.y, t.x, t.value);
                  n = n ^ e;
                }
              });
              return n;
            },
          };
        },
        {},
      ],
    },
    {},
    [1]
  )(1);
});
